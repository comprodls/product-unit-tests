<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Leaner, Meaner, Faster Animations with requestAnimationFrame - HTML5 Rocks</title>
        <link rel="stylesheet" type="text/css" href="css/core.css"/>
    </head>
    <body>
        <div class="chaptertitle">
            <h2 class="title">Leaner, Meaner, Faster Animations with requestAnimationFrame</h2>
        </div>

            <p>
                It’s a fair bet you’ve done some animation work in your time as a developer, whether that’s smaller UI effects or large iteractive canvas pieces. Chances are you’ve also come across <code>requestAnimationFrame</code>, or rAF (we say it <em>raff</em> around these parts), and hopefully you’ve had a chance to use it in your projects. In case you don’t know, <code>requestAnimationFrame</code>is the browser’s native way of handling your animations. Because rAF is specifically designed to deal with animation and rendering, the browser can schedule it at the most appropriate time and, if we play our cards right, it will help us get a buttery smooth 60 frames per second.
            </p>

            <p>
                What we want to do in this article is <strong>outline some additional ways to ensure you’re getting the maximum benefit from your animation code.</strong> Even if you’re using <code>requestAnimationFrame</code>there are other ways you can end up with bottlenecks in your animations. At 60 frames per second each frame that you draw has 16.67ms to get everything done. That’s not a lot, so every optimisation counts!
            </p>

            <blockquote>
                <p>
                    <strong>TL;DR</strong> Decouple your events from animations; avoid animations that result in reflow-repaint loops; update your rAF calls to expect a high resolution timestamp as the first parameter; only call rAF when you have visual updates to do.
                </p>
            </blockquote>

        <div class="sub_section">
            
            <h2 >Debouncing Scroll Events</h2>

            <p>Debouncing is the process of decoupling your animation from any 
            inputs that affect it. Take, for example, an effect that is triggered 
            when you scroll the page. The effect might check if some DOM elements 
            are visible to the user and then, if they are, apply some CSS classes to
             those elements.</p>

            <p>Or maybe you’re coding a parallax scrolling effect where, as you 
            scroll, background images change their position relative to page’s 
            scroll position. I’ll go with the former of the two common uses, and the
             general gist of our code might be:</p>
<pre class="prettyprint"><code><span class="kwd">function</span><span class="pln"> onScroll</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    update</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="com">// assume domElements has been declared</span><span class="pln">
    </span><span class="com">// by this point :)</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> domElements</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

        </span><span class="com">// read offset of DOM elements</span><span class="pln">
        </span><span class="com">// to determine visibility - a reflow</span><span class="pln">

        </span><span class="com">// then apply some CSS classes</span><span class="pln">
        </span><span class="com">// to the visible items    - a repaint</span><span class="pln">

    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

window</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'scroll'</span><span class="pun">,</span><span class="pln"> onScroll</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>


            <p>
                The main issue here is that we are triggering a reflow and repaint 
                whenever we get a scroll event: we ask the browser to recalculate the <strong>real positions</strong>
                of DOM elements, an expensive reflow operation, and then we apply some 
                CSS classes, which causes the browser to repaint. We end up ping-ponging
                between reflowing and repainting, and this is going to undermine your 
                app’s performance. We’re picking on scroll events here, but the same 
                applies to resize events. In fact, any event that you’re going to make 
                use of in this way can cause performance issues. Read Tony Gentilcore’s 
                Fastersite blog post for a <a class="ulink" href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html">breakdown of properties that cause a reflow in WebKit</a>.
            </p>

            <p>
                What we now need to do is decouple the scroll event from the <code>update</code> function, and this is exactly where <code>requestAnimationFrame</code>
                steps in to help. We need to change things around so that we are 
                listening to our scroll events, but we will only store the most recent 
                value:
            </p>

<pre class="prettyprint"><code><span class="kwd">var</span><span class="pln"> latestKnownScrollY </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> onScroll</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    latestKnownScrollY </span><span class="pun">=</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">scrollY</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>

            <p>
                Now we’re in a better place: <code>onScroll</code> runs whenever the 
                browser chooses to execute it, but all we’re doing is storing the 
                window’s scroll position. This code could run once, twenty or a hundred 
                times <em>before</em> we try to use the value in our animation and it 
                wouldn’t matter. The point is that we’re keeping a track on the value 
                but it’s not using it to trigger potentially unnecessary draw calls. If 
                your draw call is expensive then you’ll really benefit from avoiding 
                those extra calls.
            </p>

            <p>
                The other part of this change is to use <code>requestAnimationFrame</code> to handle the visual updates at the most convenient time for the browser:
            </p>

<pre class="prettyprint"><code><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> currentScrollY </span><span class="pun">=</span><span class="pln"> latestKnownScrollY</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// read offset of DOM elements</span><span class="pln">
    </span><span class="com">// and compare to the currentScrollY value</span><span class="pln">
    </span><span class="com">// then apply some CSS classes</span><span class="pln">
    </span><span class="com">// to the visible items</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// kick off</span><span class="pln">
requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span></code></pre>

            <p>
                Now we’re just pulling the latest value from <code>lastKnownScrollY</code>
                when we need it and discarding everything else. If you need to capture 
                all the event values since the last draw you could use an array and push
                all the values captured in <code>onScroll</code> onto it. When the time
                comes to do the drawing you could average the values or do whatever’s 
                most appropriate. In this case we’re keeping it simple and only tracking
                the last value we captured.
            </p>

            <p>What else can we do? Well for one thing we are constantly running <code>requestAnimationFrame</code>
             and that’s not necessary if we haven’t just scrolled since nothing will
             have changed. To fix that we have the onScroll initiate the <code>requestAnimationFrame</code>:</p>

<pre class="prettyprint"><code><span class="kwd">var</span><span class="pln"> latestKnownScrollY </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
    ticking </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> onScroll</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    latestKnownScrollY </span><span class="pun">=</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">scrollY</span><span class="pun">;</span><span class="pln">
    requestTick</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> requestTick</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln">ticking</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    ticking </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>

            <p>
                Now whenever we scroll we will try and call <code>requestAnimationFrame</code>, but if one is already requested we <em>don’t initiate another</em>.This is an important optimization, since the browser will stack all the repeated rAF requests and we would be back to a situation with more calls to <code>update</code> than we need.
            </p>

            <p>
                Thanks to this setup we no longer need to call <code>requestAnimationFrame</code>
                at the top of update because we know it will only be requested when one
                or more scroll events has taken place. We also no longer need the kick 
                off call at the bottom, either, so let’s update accordingly:
            </p>

<pre class="prettyprint"><code><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// reset the tick so we can</span><span class="pln">
    </span><span class="com">// capture the next onScroll</span><span class="pln">
    ticking </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> currentScrollY </span><span class="pun">=</span><span class="pln"> latestKnownScrollY</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// read offset of DOM elements</span><span class="pln">
    </span><span class="com">// and compare to the currentScrollY value</span><span class="pln">
    </span><span class="com">// then apply some CSS classes</span><span class="pln">
    </span><span class="com">// to the visible items</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// kick off - no longer needed! Woo.</span><span class="pln">
</span><span class="com">// update();</span></code></pre>

            <p>
                Hopefully you can see the benefits of debouncing the animations in 
                your app from any scroll or resize events that influence it. If you’re 
                still in any doubt, John Resig wrote a great article about how <a class="ulink" href="http://ejohn.org/blog/learning-from-twitter/">Twitter was affected by scroll events</a> a while ago. Had rAF been around back then, the above technique would have probably been his recommendation.
            </p>

        </div>

        <div class="sub_section">
            <h2>Debouncing Mouse Events</h2>
            <p>
                We’ve gone through one common use-case for using rAF to decouple 
                animations from scroll and resize events, now let’s talk about another 
                one: using it to deal with interactions. In this instance we’re going to
                 have something stick to the current mouse position, but only when the 
                mouse button is pressed. When it’s released we’ll stop the animation.
            </p>

            <p>Let’s jump straight into the code, then we’ll pick it apart:</p>

<pre class="prettyprint"><code><span class="kwd">var</span><span class="pln"> mouseIsDown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    lastMousePosition </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> x</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">};</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> onMouseDown</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    mouseIsDown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
    requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> onMouseUp</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    mouseIsDown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> onMouseMove</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    lastMousePosition</span><span class="pun">.</span><span class="pln">x </span><span class="pun">=</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">clientX</span><span class="pun">;</span><span class="pln">
    lastMousePosition</span><span class="pun">.</span><span class="pln">y </span><span class="pun">=</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">clientY</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">mouseIsDown</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// now draw object at lastMousePosition</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

document</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'mousedown'</span><span class="pun">,</span><span class="pln"> onMouseDown</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
document</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'mouseup'</span><span class="pun">,</span><span class="pln">   onMouseUp</span><span class="pun">,</span><span class="pln">   </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
document</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'mousemove'</span><span class="pun">,</span><span class="pln"> onMouseMove</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>

            <p>
                In this instance we are setting a boolean (<code>mouseIsDown</code>) depending on whether or not the mouse button is currently pressed. We can also piggy back on the <code>mousedown</code> event to initiate the first <code>requestAnimationFrame</code>
                call, which is handy. As we move the mouse we do a similar trick to the
                previous example where we simply store the last known position of the 
                mouse, which we later use in the <code>update</code> function. The last thing to notice is that <code>update</code> requests the next animation frame until we’ve called <code>onMouseUp</code> and <code>mouseIsDown</code> is set back to <code>false</code>.
            </p>

            <p>
                Again our tactic here is to let the mouse events all proceed as often
                as the browser deems necessary, and we have the draw calls happen <em>independently</em> of those events. Not dissimilar to what we do with scroll events.
            </p>

            <p>
                If things are a little more complex and you’re animating something that carries on moving after <code>onMouseUp</code> has been called, you’ll need to manage the calls to <code>requestAnimationFrame</code>
                differently. A suitable solution is to track the position of the 
                animating object and when the change on two subsequent frames drops 
                below a certain threshold you stop calling <code>requestAnimationFrame</code>. The changes to our code would look a little like this:
            </p>

<pre class="prettyprint"><code><span class="kwd">var</span><span class="pln"> mouseIsDown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    lastMousePosition </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> x</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">},</span><span class="pln">
    rAFIndex </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> onMouseDown</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    mouseIsDown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// cancel the existing rAF</span><span class="pln">
    cancelAnimationFrame</span><span class="pun">(</span><span class="pln">rAFIndex</span><span class="pun">);</span><span class="pln">

    rAFIndex </span><span class="pun">=</span><span class="pln"> requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// other event handlers as above</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> objectHasMovedEnough </span><span class="pun">=</span><span class="pln"> calculateObjectMovement</span><span class="pun">();</span><span class="pln">

    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">objectHasMovedEnough</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        rAFIndex </span><span class="pun">=</span><span class="pln"> requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// now draw object at lastMousePosition</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> calculateObjectMovement</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> hasMovedFarEnough </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// here we would perhaps use velocities</span><span class="pln">
    </span><span class="com">// and so on to capture the object</span><span class="pln">
    </span><span class="com">// movement and set hasMovedFarEnough</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> hasMovedFarEnough</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>

            <p>
                The main change in the above comes from the fact that if you release 
                the mouse the rAF calls would continue until the object has come to a 
                rest <em>but</em> you may start clicking and dragging again meaning you would get a second rAF call scheduled <em>as well as the original</em>. Not good. To combat this we make sure to cancel any scheduled <code>requestAnimationFrame</code> call (in <code>onMouseDown</code>) before we set about issuing a new one.
            </p>

        </div>
        <div class="sub_section">
            <h2>requestAnimationFrame and High Resolution Timestamp</h2>

            <p>
                 While we’re spending some time talking about <code>requestAnimationFrame</code>
                 it’s worth noting to how callbacks are handled. The parameter passed to
                 your callback function is a high resolution timestamp, accurate to a 
                 fraction of a millisecond. Two things about this:
            </p>

            <ol>
                  <li>It’s awesome for your animations if they’re time-based because now they can be really accurate</li>
                  <li>You need to update any code you have written that expects an object or element to be the first parameter</li>
            </ol>

            <p>
                Get the full rundown of this at: <a class="ulink" href="http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision">requestAnimationFrame API: now with sub-millisecond precision</a>
            </p>

        </div>

        <div class="sub_section">
            <p>
                OK, let’s finish this article off with an example, just so you can 
                see it all in action. It’s slightly contrived, and we’ll also throw in a
                bonus performance killer that we can fix as we go. Way too much fun!
            </p>

            <p>
                We have a document with 800 DOM elements that we’re going to move 
                when you scroll the mouse. Because we’re well-versed in modern web 
                development we’re going to use CSS transitions and <code>requestAnimationFrame</code>
                 from the off. As we scroll down the page we’ll determine which of our 
                800 DOM elements are now above the middle of the visible area of the 
                screen and we’ll move them over to the left hand side by adding a <code>left</code> class.
            </p>

            <p>
                It’s worth bearing in mind that we’ve chosen such a large number of 
                elements because it will allow us to really see any performance issues 
                more easily. And there are some.
            </p>

            <p>Here’s what our JavaScript looks like:</p>

<pre class="prettyprint"><code><span class="kwd">var</span><span class="pln"> movers </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.mover'</span><span class="pun">);</span><span class="pln">

</span><span class="com">/**
 * Set everthing up and position all the DOM elements
 * - normally done with the CSS but, hey, there's heaps
 * of them so we're doing it here!
 */</span><span class="pln">
</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> init</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> m </span><span class="pun">&lt;</span><span class="pln"> movers</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        movers</span><span class="pun">[</span><span class="pln">m</span><span class="pun">].</span><span class="pln">style</span><span class="pun">.</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m </span><span class="pun">*</span><span class="pln"> </span><span class="lit">10</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'px'</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

</span><span class="pun">})();</span><span class="pln">

</span><span class="com">/**
 * Our animation loop - called by rAF
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="com">// grab the latest scroll position</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> scrollY             </span><span class="pun">=</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">scrollY</span><span class="pun">,</span><span class="pln">
        mover               </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
        moverTop            </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
        halfWindowHeight    </span><span class="pun">=</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">innerHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">,</span><span class="pln">
        offset              </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// now loop through each mover div</span><span class="pln">
    </span><span class="com">// and change its class as we go</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> m </span><span class="pun">&lt;</span><span class="pln"> movers</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

        mover       </span><span class="pun">=</span><span class="pln"> movers</span><span class="pun">[</span><span class="pln">m</span><span class="pun">];</span><span class="pln">
        moverTop</span><span class="pun">[</span><span class="pln">m</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mover</span><span class="pun">.</span><span class="pln">offsetTop</span><span class="pun">;</span><span class="pln">

        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">scrollY </span><span class="pun">&gt;</span><span class="pln"> moverTop</span><span class="pun">[</span><span class="pln">m</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> halfWindowHeight</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            mover</span><span class="pun">.</span><span class="pln">className </span><span class="pun">=</span><span class="pln"> </span><span class="str">'mover left'</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            mover</span><span class="pun">.</span><span class="pln">className </span><span class="pun">=</span><span class="pln"> </span><span class="str">'mover'</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// keep going</span><span class="pln">
    requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// schedule up the start</span><span class="pln">
window</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'load'</span><span class="pun">,</span><span class="pln"> update</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>

            <div class="figure">
                <span id="reference-diagram" />
                    <div class="figure-contents">
                   
                         <img src="images/ch05_sec04_pre-particle.jpg">
                  
                    </div>
                <div class="figure-title">Our demo page before performance and rAF optimizations</div>
            </div>

            <p>
                If you check out the <a class="ulink" href="http://www.html5rocks.com/en/tutorials/speed/animations/pre.html">pre-optimized page</a>
                you’ll see it really struggle to keep up as you scroll, and there are a
                number of reasons why. Firstly we are brute force calling the <code>requestAnimationFrame</code>, whereas what we really should do is only calculate any changes when we get a scroll event. Secondly we are calling <code>offsetTop</code> which causes a reflow, but then we immediately apply the <code>className</code> change and that’s going to cause a repaint. And then thirdly, for our bonus performance killer, we are using <code>className</code> rather than <code>classList</code>.
            </p>

            <p>
                The reason using <code>className</code> is less performant than <code>classList</code> is that <code>className</code> will <em>always</em> affect the DOM element, even if the value of <code>className</code> hasn’t changed. By just setting the value we trigger a repaint, which can be very expensive. Using <code>classList</code>,
                however, allows the browser to be much more intelligent about updates, 
                and it will leave the element alone should the list already contain the 
                class you’re adding (which is <code>left</code> in our case).
            </p>

            <p>
                If you want more information on using <code>classList</code> and the new-and-extremely-useful frame breakdown mode in Chrome’s Dev Tools you should watch this video by Paul Irish:
            </p>

            <iframe src="https://www.youtube.com/embed/hZJacl2VkKo?feature=player_embedded"   height="360" width="640"></iframe>
            <p>So let’s take a look at what a better version of this would look like:</p>

<pre class="prettyprint"><code><span class="kwd">var</span><span class="pln"> movers          </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.mover'</span><span class="pun">),</span><span class="pln">
    lastScrollY     </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
    ticking         </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

</span><span class="com">/**
 * Set everthing up and position all the DOM elements
 * - normally done with the CSS but, hey, there's heaps
 * of them so we're doing it here!
 */</span><span class="pln">
</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> init</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> m </span><span class="pun">&lt;</span><span class="pln"> movers</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        movers</span><span class="pun">[</span><span class="pln">m</span><span class="pun">].</span><span class="pln">style</span><span class="pun">.</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m </span><span class="pun">*</span><span class="pln"> </span><span class="lit">10</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'px'</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

</span><span class="pun">})();</span><span class="pln">

</span><span class="com">/**
 * Callback for our scroll event - just
 * keeps track of the last scroll value
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> onScroll</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    lastScrollY </span><span class="pun">=</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">scrollY</span><span class="pun">;</span><span class="pln">
    requestTick</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">/**
 * Calls rAF if it's not already
 * been done already
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> requestTick</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln">ticking</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        requestAnimationFrame</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
        ticking </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">/**
 * Our animation callback
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> update</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> mover               </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
        moverTop            </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
        halfWindowHeight    </span><span class="pun">=</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">innerHeight </span><span class="pun">*</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">,</span><span class="pln">
        offset              </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// first loop is going to do all</span><span class="pln">
    </span><span class="com">// the reflows (since we use offsetTop)</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> m </span><span class="pun">&lt;</span><span class="pln"> movers</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

        mover       </span><span class="pun">=</span><span class="pln"> movers</span><span class="pun">[</span><span class="pln">m</span><span class="pun">];</span><span class="pln">
        moverTop</span><span class="pun">[</span><span class="pln">m</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mover</span><span class="pun">.</span><span class="pln">offsetTop</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// second loop is going to go through</span><span class="pln">
    </span><span class="com">// the movers and add the left class</span><span class="pln">
    </span><span class="com">// to the elements' classlist</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> m </span><span class="pun">&lt;</span><span class="pln"> movers</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

        mover       </span><span class="pun">=</span><span class="pln"> movers</span><span class="pun">[</span><span class="pln">m</span><span class="pun">];</span><span class="pln">

        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">lastScrollY </span><span class="pun">&gt;</span><span class="pln"> moverTop</span><span class="pun">[</span><span class="pln">m</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> halfWindowHeight</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            mover</span><span class="pun">.</span><span class="pln">classList</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="str">'left'</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            mover</span><span class="pun">.</span><span class="pln">classList</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="str">'left'</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// allow further rAFs to be called</span><span class="pln">
    ticking </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// only listen for scroll events</span><span class="pln">
window</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'scroll'</span><span class="pun">,</span><span class="pln"> onScroll</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>


             <div class="figure">
                <span id="reference-diagram" />
                    <div class="figure-contents">
                   
                         <a class="ulink" href="http://www.html5rocks.com/en/tutorials/speed/animations/post.html">
                            <img src="images/ch05_sec04_post-particle.jpg">
                        </a>
                  
                    </div>
                <div class="figure-title">Our demo page after performance and rAF optimizations</div>
            </div>

            <p>
                If you look at <a class="ulink" href="http://www.html5rocks.com/en/tutorials/speed/animations/post.html">our new optimized version of the demo</a> you will see much smoother animations as you scroll up and down the page. We’ve stopped calling <code>requestAnimationFrame</code> indiscriminantly, we now only do it when we scroll (and we ensure there is only one call scheduled). We’ve also moved the <code>offsetTop</code>property lookups into one loop and put the class changes into a second 
                loop which means that we’re avoiding the reflow-repaint problem. We’ve 
                decoupled our events from the draw call so they can happen as often as 
                they like and we won’t be doing unnecessary drawing. Finally we’ve 
                switched out <code>className</code> for <code>classList</code>, which is a massive performance saver.
            </p>

            <p>
                Of course there are other things we can do to take this further, in particular not iterating through <em>all 800</em> DOM elements on each pass, but even just the changes we’ve made have given us great performance improvements.
            </p>
        </div>

        <div class="sub_section">
            <h2 id="conclusion">Conclusion</h1>

            <p>
                It’s important to not only use <code>requestAnimationFrame</code> for
                your animations, but also to use it in the right way. As you can 
                hopefully see it’s quite easy to inadvertently cause bottlenecks, but by
                understanding how the browser actually executes your code you can fix 
                any problems quickly. Take some time with Chrome’s Dev Tools, especially
                the frame mode, and see where your animations can be improved.
            </p>

        </div>
    </body>

</html>