<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Project: A Paint Program</title>
    <link rel="stylesheet" href="style.css"/>
  </head>
  <body>
    <article>

<h1 id="paint"><span class="chap_num">Chapter 19</span>Project: A Paint Program</h1>
<blockquote>
<p>I look at the many colors before me. I look at
my blank canvas. Then, I try to apply colors like words that shape
poems, like notes that shape music.</p>
 <footer>Joan Miro</footer>
</blockquote>
<p>The material from the previous chapters gives you all the
elements you need to build a simple web application. In this
chapter, we will do just that.</p>
<p>Our application will be a web-based drawing program, along
the lines of Microsoft Paint. You can use it to open image
files, scribble on them with your mouse, and save them. This
is what it will look like:</p>
<div class="image">
  <img src="img/paint.png" alt="A simple paint program"/>
</div>
<p>Painting on a computer is great. You don&#8217;t need to worry about
materials, skill, or talent. You just start smearing.</p>
<div id="ch19_sec01">
<h2>Implementation</h2>
<p>The
interface for the paint program shows a big <code>&lt;canvas&gt;</code> element on top,
with a number of form fields below it. The user draws on the
picture by selecting a tool from a <code>&lt;select&gt;</code> field and then
clicking or dragging across the canvas. There are tools for
drawing lines, erasing parts of the picture, adding text, and so on.</p>
<p>Clicking the canvas will hand off the
<code>"mousedown"</code> event to the currently selected tool, which can handle
it in whichever way it chooses. The line drawing tool, for
example, will listen for <code>"mousemove"</code> events until the mouse button
is released and draw lines along the mouse&#8217;s path using the current
color and brush size.</p>
<p>Color and brush size are selected with
additional form fields. These are hooked up to update the canvas
drawing context&#8217;s <code>fillStyle</code>, <code>strokeStyle</code>, and <code>lineWidth</code> whenever
they are changed.</p>
<p>You can load an image into the program in two ways. The
first uses a file field, where the user can select a file on their own
file system. The second asks for a URL and will fetch an
image from the Web.</p>
<p>Images are saved in a somewhat atypical way. The
save link at the right side points at the current image. It
can be followed, shared, or saved. I will explain how this is achieved
in a moment.</p>
</div>
<div id="ch19_sec02">
<h2>Building the DOM</h2>
<p>Our program&#8217;s interface is built from more than 30 DOM elements. We
need to construct these somehow.</p>
<p>HTML is the
most obvious format for defining complex DOM structures. But
separating the program into a piece of HTML and a script is made
difficult by the fact that many of the DOM elements need event
handlers or have to be touched by the script in some other way. Thus,
our script would have to make lots of <code>querySelector</code> (or similar)
calls in order to find the DOM elements that it needs to act on.</p>
<p>It would be nice if the DOM structure for each part of our
interface is defined close to the JavaScript code that drives it.
Thus, I&#8217;ve chosen to do all creation of DOM nodes in JavaScript. As we
saw in <a href="13_dom.xhtml#standard">Chapter 13</a>, the built-in interface
for building up a DOM structure is horrendously verbose. If we are
going to do a lot of DOM construction, we need a helper function.</p>
<p>This helper function is an extended version of the
<code>elt</code> function from <a href="13_dom.xhtml#elt">Chapter 13</a>. It creates an
element with the given name and attributes and appends all
further arguments it gets as child nodes, automatically converting
strings to text nodes.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">elt</span>(<span class="cm-def">name</span>, <span class="cm-def">attributes</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">attributes</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">attr</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">attributes</span>)
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">attributes</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">attr</span>))
        <span class="cm-variable-2">node</span>.<span class="cm-property">setAttribute</span>(<span class="cm-variable-2">attr</span>, <span class="cm-variable-2">attributes</span>[<span class="cm-variable-2">attr</span>]);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">child</span> <span class="cm-operator">=</span> <span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">child</span> <span class="cm-operator">==</span> <span class="cm-string">"string"</span>)
      <span class="cm-variable-2">child</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">child</span>);
    <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>;
}</pre>
<p>This allows us to create elements easily, without making our source
code as long and dull as a corporate end-user agreement.</p>
</div>
<div id="ch19_sec03">
<h2>The foundation</h2>
<p>The core of our program
is the <code>createPaint</code> function, which appends the paint interface to
the DOM element it is given as an argument. Because we want to build our
program piece by piece, we define an object called <code>controls</code>, which will
hold functions to initialize the various controls below the image.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">controls</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">createPaint</span>(<span class="cm-def">parent</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"canvas"</span>, {<span class="cm-property">width</span>: <span class="cm-number">500</span>, <span class="cm-property">height</span>: <span class="cm-number">300</span>});
  <span class="cm-keyword">var</span> <span class="cm-def">cx</span> <span class="cm-operator">=</span> <span class="cm-variable-2">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">toolbar</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, {<span class="cm-keyword">class</span>: <span class="cm-string">"toolbar"</span>});
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">controls</span>)
    <span class="cm-variable-2">toolbar</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">controls</span>[<span class="cm-variable-2">name</span>](<span class="cm-variable-2">cx</span>));

  <span class="cm-keyword">var</span> <span class="cm-def">panel</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, {<span class="cm-keyword">class</span>: <span class="cm-string">"picturepanel"</span>}, <span class="cm-variable-2">canvas</span>);
  <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-atom">null</span>, <span class="cm-variable-2">panel</span>, <span class="cm-variable-2">toolbar</span>));
}</pre>
<p>Each control has access to the canvas
drawing context and, through that context&#8217;s <code>canvas</code> property, to the
<code>&lt;canvas&gt;</code> element. Most of the program&#8217;s state lives in this
canvas—it contains the current picture as well as the selected color
(in its <code>fillStyle</code> property) and brush size (in its <code>lineWidth</code>
property).</p>
<p>We wrap the canvas and the controls in
<code>&lt;div&gt;</code> elements with classes so we can add some styling, such as
a gray border around the picture.</p>
</div>
<div id="ch19_sec04">
<h2>Tool selection</h2>
<p>The first control we add is the <code>&lt;select&gt;</code> element that
allows the user to pick a drawing tool. As with <code>controls</code>, we
will use an object to collect the various tools so that we do not
have to hard-code them all in one place and can add more tools later.
This object associates the names of the tools with the function that
should be called when they are selected and the canvas is clicked.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">tools</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">controls</span>.<span class="cm-property">tool</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"select"</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">tools</span>)
    <span class="cm-variable-2">select</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"option"</span>, <span class="cm-atom">null</span>, <span class="cm-variable-2">name</span>));

  <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">tools</span>[<span class="cm-variable-2">select</span>.<span class="cm-property">value</span>](<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>);
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  });

  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Tool: "</span>, <span class="cm-variable-2">select</span>);
};</pre>
<p>The tool field is populated with
<code>&lt;option&gt;</code> elements for all tools that have been defined, and a
<code>"mousedown"</code> handler on the canvas element takes care of calling the
function for the current tool, passing it both the event object
and the drawing context as arguments. It also calls
<code>preventDefault</code> so that holding the mouse button and dragging does
not cause the browser to select parts of the page.</p>
<p>The most basic
tool is the line tool, which allows the user to draw lines with
the mouse. To put the line ends in the right place, we
need to be able to find the canvas-relative coordinates that a
given mouse event corresponds to. The <code>getBoundingClientRect</code> method,
briefly mentioned in <a href="13_dom.xhtml#boundingRect">Chapter 13</a>, can
help us here. It tells us where an element is shown, relative to the
top-left corner of the screen. The <code>clientX</code> and <code>clientY</code> properties
on mouse events are also relative to this corner, so we can subtract
the top-left corner of the canvas from them to get a position relative
to that corner.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">relativePos</span>(<span class="cm-def">event</span>, <span class="cm-def">element</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable-2">element</span>.<span class="cm-property">getBoundingClientRect</span>();
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">clientX</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">left</span>),
          <span class="cm-property">y</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">clientY</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">top</span>)};
}</pre>
<p>Several of the drawing tools need to listen for
<code>"mousemove"</code> events as long as the mouse button is held down. The
<code>trackDrag</code> function takes care of the event registration and
unregistration for such situations.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">trackDrag</span>(<span class="cm-def">onMove</span>, <span class="cm-def">onEnd</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">end</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable-2">onMove</span>);
    <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-variable-2">end</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">onEnd</span>)
      <span class="cm-variable-2">onEnd</span>(<span class="cm-variable-2">event</span>);
  }
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable-2">onMove</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-variable-2">end</span>);
}</pre>
<p>This function takes two arguments. One is a function to call for each
<code>"mousemove"</code> event, and the other is a function to call when the
mouse button is released. Either argument can be omitted when it
is not needed.</p>
<p>The line tool uses these two helpers to do the actual
drawing.</p>
<pre><span class="cm-variable">tools</span>.<span class="cm-property">Line</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>, <span class="cm-def">onEnd</span>) {
  <span class="cm-variable-2">cx</span>.<span class="cm-property">lineCap</span> <span class="cm-operator">=</span> <span class="cm-string">"round"</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  <span class="cm-variable">trackDrag</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-variable-2">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">stroke</span>();
  }, <span class="cm-variable-2">onEnd</span>);
};</pre>
<p>The function starts by setting the drawing
context&#8217;s <code>lineCap</code> property to <code>"round"</code>, which causes both ends of
a stroked path to be round rather than the default square form.
This is a trick to make sure that multiple separate lines, drawn in
response to separate events, look like a single, coherent line. With
bigger line widths, you will see gaps at corners if you use the default flat
line caps.</p>
<p>Then, for every <code>"mousemove"</code> event that occurs as long as
the mouse button is down, a simple line segment is drawn between the
mouse&#8217;s old and new position, using whatever <code>strokeStyle</code> and
<code>lineWidth</code> happen to be currently set.</p>
<p>The <code>onEnd</code> argument to <code>tools.Line</code> is simply passed
through to <code>trackDrag</code>. The normal way to run tools won&#8217;t pass a third
argument, so when using the line tool, that argument will hold
<code>undefined</code>, and nothing happens at the end of the mouse drag. The
argument is there to allow us to implement the erase tool on top of
the line tool with very little additional code.</p>
<pre><span class="cm-variable">tools</span>.<span class="cm-property">Erase</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-variable-2">cx</span>.<span class="cm-property">globalCompositeOperation</span> <span class="cm-operator">=</span> <span class="cm-string">"destination-out"</span>;
  <span class="cm-variable">tools</span>.<span class="cm-property">Line</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">globalCompositeOperation</span> <span class="cm-operator">=</span> <span class="cm-string">"source-over"</span>;
  });
};</pre>
<p>The <code>globalCompositeOperation</code> property influences the way
drawing operations on a canvas change the color of the pixels they
touch. By default, the property&#8217;s value is <code>"source-over"</code>, which means that the drawn
color is overlaid on the existing color at that spot. If the color is
opaque, it will simply replace the old color, but if it is
partially transparent, the two will be mixed.</p>
<p>The erase tool sets <code>globalCompositeOperation</code> to
<code>"destination-out"</code>, which has the effect of erasing the pixels we
touch, making them transparent again.</p>
<p>That gives us two tools in our paint program. We can draw
black lines a single pixel wide (the default <code>strokeStyle</code> and
<code>lineWidth</code> for a canvas) and erase them again. It is a working,
albeit rather limited, paint program.</p>
</div>
<div id="ch19_sec05">
<h2>Color and brush size</h2>
<p>Assuming that users will want to draw in
colors other than black and use different brush sizes, let&#8217;s
add controls for those two settings.</p>
<p>In
<a href="18_forms.xhtml#forms">Chapter 18</a>, I discussed a number of
different form fields. Color fields were not among those.
Traditionally, browsers don&#8217;t have built-in support for color
pickers, but in the past few years, a number of new form field types have
been standardized. One of those is <code>&lt;input type="color"&gt;</code>. Others
include <code>"date"</code>, <code>"email"</code>, <code>"url"</code>, and <code>"number"</code>. Not all
browsers support them yet—at the time of writing, no version of
Internet Explorer supports color fields. The default type of
an <code>&lt;input&gt;</code> tag is <code>"text"</code>, and when an unsupported type is used,
browsers will treat it as a text field. This means that Internet
Explorer users running our paint program will have to type in the name
of the color they want, rather than select it from a convenient
widget.</p>
<p>This is what a color picker may look like:</p>
<div class="image">
  <img src="img/color-field.png" alt="A color field"/>
</div>
<pre><span class="cm-variable">controls</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"color"</span>});
  <span class="cm-variable-2">input</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Color: "</span>, <span class="cm-variable-2">input</span>);
};</pre>
<p>Whenever the value of the color field changes, the drawing
context&#8217;s <code>fillStyle</code> and <code>strokeStyle</code> are updated to hold the new
value.</p>
<p>The field for configuring the brush size works similarly.</p>
<pre><span class="cm-variable">controls</span>.<span class="cm-property">brushSize</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"select"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">sizes</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">8</span>, <span class="cm-number">12</span>, <span class="cm-number">25</span>, <span class="cm-number">35</span>, <span class="cm-number">50</span>, <span class="cm-number">75</span>, <span class="cm-number">100</span>];
  <span class="cm-variable-2">sizes</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">size</span>) {
    <span class="cm-variable-2">select</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"option"</span>, {<span class="cm-property">value</span>: <span class="cm-variable-2">size</span>},
                           <span class="cm-variable-2">size</span> <span class="cm-operator">+</span> <span class="cm-string">" pixels"</span>));
  });
  <span class="cm-variable-2">select</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-variable-2">select</span>.<span class="cm-property">value</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Brush size: "</span>, <span class="cm-variable-2">select</span>);
};</pre>
<p>The code generates options from an array of brush
sizes, and again ensures that the canvas’ <code>lineWidth</code> is updated when
a brush size is chosen.</p>
</div>
<div id="ch19_sec06">
<h2>Saving</h2>
<p>To explain the implementation of the save link, I
must first tell you about <em>data URLs</em>. A data URL is a URL
with <em>data:</em> as its protocol. Unlike regular <em>http:</em> and <em>https:</em>
URLs, data URLs don&#8217;t point at a resource but rather contain the entire
resource in them. This is a data URL containing a
simple HTML document:</p>
<pre>data:text/html,&lt;h1 style="color:red"&gt;Hello!&lt;/h1&gt;</pre>
<p>Data URLs are useful for various tasks, such as including small
images directly in a style sheet file. They also allow us to link
to files that we created on the client side, in the browser, without
first moving them to some server.</p>
<p>Canvas elements have a convenient method, called <code>toDataURL</code>,
which will return a data URL that contains the picture on the canvas
as an image file. We don&#8217;t want to update our save link every time
the picture is changed, however. For big pictures, that involves moving
quite a lot of data into a link and would be noticeably slow.
Instead, we rig the link to update its <code>href</code> attribute whenever it is
focused with the keyboard or the mouse is moved over it.</p>
<pre><span class="cm-variable">controls</span>.<span class="cm-property">save</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">link</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"a"</span>, {<span class="cm-property">href</span>: <span class="cm-string">"/"</span>}, <span class="cm-string">"Save"</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">update</span>() {
    <span class="cm-keyword">try</span> {
      <span class="cm-variable-2">link</span>.<span class="cm-property">href</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">toDataURL</span>();
    } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">SecurityError</span>)
        <span class="cm-variable-2">link</span>.<span class="cm-property">href</span> <span class="cm-operator">=</span> <span class="cm-string">"javascript:alert("</span> <span class="cm-operator">+</span>
          <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-string">"Can't save: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">e</span>.<span class="cm-property">toString</span>()) <span class="cm-operator">+</span> <span class="cm-string">")"</span>;
      <span class="cm-keyword">else</span>
        <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
    }
  }
  <span class="cm-variable-2">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseover"</span>, <span class="cm-variable-2">update</span>);
  <span class="cm-variable-2">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"focus"</span>, <span class="cm-variable-2">update</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">link</span>;
};</pre>
<p>Thus, the link just
quietly sits there, pointing at the wrong thing, but when the user
approaches it, it magically updates itself to point at the current
picture.</p>
<p>If you load a big image, some browsers will choke on the
giant data URLs that this produces. For small pictures, this
approach works without problem.</p>
<p>But here we once
again run into the subtleties of browser sandboxing. When an
image is loaded from a URL on another domain, if the server&#8217;s
response doesn&#8217;t include a header that tells the browser the
resource may be used from other domains (see
<a href="17_http.xhtml#http_sandbox">Chapter 17</a>), then the canvas will
contain information that the <em>user</em> may look at but that the
<em>script</em> may not.</p>
<p>We may have requested a picture that contains
private information (for example, a graph showing the user&#8217;s bank
account balance) using the user&#8217;s session. If scripts could get
information out of that picture, they could snoop on the user in
undesirable ways.</p>
<p>To prevent these kinds of information
leaks, browsers will mark a canvas as <em>tainted</em> when an image
that the script may not see is drawn onto it. Pixel data, including
data URLs, may not be extracted from a tainted canvas. You can write
to it, but you can no longer read it.</p>
<p>This is why we need the
<code>try/catch</code> statement in the <code>update</code> function for the save link.
When the canvas has become tainted, calling <code>toDataURL</code> will raise an
exception that is an instance of <code>SecurityError</code>. When that happens, we
set the link to point at yet another kind of URL, using the
<em>javascript:</em> protocol. Such links simply execute the script given
after the colon when they are followed so that the link will show an
<code>alert</code> window informing the user of the problem when it is clicked.</p>
</div>
<div id="ch19_sec07">
<h2>Loading image files</h2>
<p>The final two
controls are used to load images from local files and from URLs.
We&#8217;ll need the following helper function, which tries to load an image
file from a URL and replace the contents of the canvas with it:</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">loadImageURL</span>(<span class="cm-def">cx</span>, <span class="cm-def">url</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">image</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable-2">image</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">color</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span>, <span class="cm-def">size</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">image</span>.<span class="cm-property">width</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">image</span>.<span class="cm-property">height</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable-2">image</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-variable-2">size</span>;
  });
  <span class="cm-variable-2">image</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-variable-2">url</span>;
}</pre>
<p>We want to change the
size of the canvas to precisely fit the image. For some reason,
changing the size of a canvas will cause its drawing context to forget
configuration properties such as <code>fillStyle</code> and <code>lineWidth</code>, so the
function saves those and restores them after it has updated the canvas
size.</p>
<p>The control for loading
a local file uses the <code>FileReader</code> technique from
<a href="18_forms.xhtml#filereader">Chapter 18</a>. Apart from the <code>readAsText</code>
method we used there, such reader objects also have a method called
<code>readAsDataURL</code>, which is exactly what we need here. We load the
file that the user chose as a data URL and pass it to
<code>loadImageURL</code> to put it into the canvas.</p>
<pre><span class="cm-variable">controls</span>.<span class="cm-property">openFile</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"file"</span>});
  <span class="cm-variable-2">input</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">reader</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">FileReader</span>();
    <span class="cm-variable-2">reader</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-variable">loadImageURL</span>(<span class="cm-variable-2">cx</span>, <span class="cm-variable-2">reader</span>.<span class="cm-property">result</span>);
    });
    <span class="cm-variable-2">reader</span>.<span class="cm-property">readAsDataURL</span>(<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>[<span class="cm-number">0</span>]);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Open file: "</span>, <span class="cm-variable-2">input</span>);
};</pre>
<p>Loading a file from a URL is even simpler. But with a text field, it is less clear when the user has finished writing the URL,
so we can&#8217;t simply listen for <code>"change"</code> events. Instead, we will wrap
the field in a form and respond when the form is submitted, either
because the user pressed Enter or because they clicked the load
button.</p>
<pre><span class="cm-variable">controls</span>.<span class="cm-property">openURL</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"text"</span>});
  <span class="cm-keyword">var</span> <span class="cm-def">form</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"form"</span>, <span class="cm-atom">null</span>,
                 <span class="cm-string">"Open URL: "</span>, <span class="cm-variable-2">input</span>,
                 <span class="cm-variable">elt</span>(<span class="cm-string">"button"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"submit"</span>}, <span class="cm-string">"load"</span>));
  <span class="cm-variable-2">form</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"submit"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    <span class="cm-variable">loadImageURL</span>(<span class="cm-variable-2">cx</span>, <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">form</span>;
};</pre>
<p>We have now defined all the controls that our simple paint program
needs, but it could still use a few more tools.</p>
</div>
<div id="ch19_sec08">
<h2>Finishing up</h2>
<p>We can easily add a text tool that
uses <code>prompt</code> to ask the user which string it should draw.</p>
<pre><span class="cm-variable">tools</span>.<span class="cm-property">Text</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-string">"Text:"</span>, <span class="cm-string">""</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">text</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">font</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-number">7</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span>) <span class="cm-operator">+</span> <span class="cm-string">"px sans-serif"</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillText</span>(<span class="cm-variable-2">text</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  }
};</pre>
<p>You could add extra fields for the font size and the
font, but for simplicity&#8217;s sake, we always use a sans-serif font and
base the font size on the current brush size. The minimum size is 7
pixels because text smaller than that is unreadable.</p>
<p>Another indispensable tool
for drawing amateurish computer graphics is the spray paint tool.
This one draws dots in random locations under the brush as long as
the mouse is held down, creating denser or less dense speckling
based on how fast or slow the mouse moves.</p>
<pre><span class="cm-variable">tools</span>.<span class="cm-property">Spray</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">radius</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">area</span> <span class="cm-operator">=</span> <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">dotsPerTick</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">area</span> <span class="cm-operator">/</span> <span class="cm-number">30</span>);

  <span class="cm-keyword">var</span> <span class="cm-def">currentPos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">spray</span> <span class="cm-operator">=</span> <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">dotsPerTick</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">offset</span> <span class="cm-operator">=</span> <span class="cm-variable">randomPointInRadius</span>(<span class="cm-variable-2">radius</span>);
      <span class="cm-variable-2">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-variable-2">currentPos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">offset</span>.<span class="cm-property">x</span>,
                  <span class="cm-variable-2">currentPos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">offset</span>.<span class="cm-property">y</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
    }
  }, <span class="cm-number">25</span>);
  <span class="cm-variable">trackDrag</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">currentPos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  }, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">clearInterval</span>(<span class="cm-variable-2">spray</span>);
  });
};</pre>
<p>The spray tool uses
<code>setInterval</code> to spit out colored dots every 25 milliseconds as long
as the mouse button is held down. The <code>trackDrag</code> function is used to
keep <code>currentPos</code> pointing at the current mouse position and to turn
off the interval when the mouse button is released.</p>
<p>To determine how many dots to draw every time the interval fires, the
function computes the area of the current brush and divides that
by 30. To find a random position under the brush, the <code>randomPointInRadius</code>
function is used.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">randomPointInRadius</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">for</span> (;;) {
    <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">1</span>)
      <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span>, <span class="cm-property">y</span>: <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span>};
  }
}</pre>
<p>This function generates points in the square between (-1,-1)
and (1,1). Using the Pythagorean theorem, it tests whether the generated point lies within a circle
of radius 1. As soon as the function finds such a point, it returns the point
multiplied by the <code>radius</code> argument.</p>
<p>The loop
is necessary for a uniform distribution of dots. The straightforward way
of generating a random point within a circle would be to use a random angle and distance and
call <code>Math.sin</code> and <code>Math.cos</code> to create the corresponding point. But with that method,
the dots are more likely to appear near the center of the circle.
There are other ways around that, but they&#8217;re more complicated than the previous loop.</p>
<p>We now have a functioning paint program.</p>
</div>
<div id="ch19_sec09">
<h2>Exercises</h2>
<p>There is still plenty of room for improvement in this program. Let&#8217;s
add a few more features as exercises.</p>
<h3>Rectangles</h3>
<p>Define a tool
called <code>Rectangle</code> that fills a rectangle (see the <code>fillRect</code> method
from <a href="16_canvas.xhtml#fill_stroke">Chapter 16</a>) with the current
color. The rectangle should span from the point where the user pressed
the mouse button to the point where they released it. Note that
the latter might be above or to the left of the former.</p>
<p>Once it works, you&#8217;ll notice that it is somewhat
jarring to not see the rectangle as you are dragging the mouse to
select its size. Can you come up with a way to show some kind of
rectangle during the dragging, without actually drawing to the canvas
until the mouse button is released?</p>
<p>If nothing comes to mind, think back to the <code>position:
absolute</code> style discussed in
<a href="13_dom.xhtml#animation">Chapter 13</a>, which can be used to overlay a
node on the rest of the document. The <code>pageX</code> and <code>pageY</code> properties
of a mouse event can be used to position an element precisely under
the mouse, by setting the <code>left</code>, <code>top</code>, <code>width</code>, and <code>height</code> styles
to the correct pixel values.</p>
<h3>Color picker</h3>
<p>Another tool that is commonly found in
graphics programs is a color picker, which allows the user to
click the picture and selects the color under the mouse pointer.
Build this.</p>
<p>For
this tool, we need a way to access the content of the canvas. The
<code>toDataURL</code> method more or less did that, but getting pixel
information out of such a data URL is hard. Instead, we&#8217;ll use the
<code>getImageData</code> method on the drawing context, which returns a
rectangular piece of the image as an object with <code>width</code>, <code>height</code>,
and <code>data</code> properties. The <code>data</code> property holds an array of numbers
from 0 to 255, using four numbers to represent each pixel&#8217;s red,
green, blue, and alpha (opaqueness) components.</p>
<p>This example retrieves the numbers for a single pixel from a canvas
once when the canvas is blank (all pixels are transparent black) and
once when the pixel has been colored red.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">pixelAt</span>(<span class="cm-def">cx</span>, <span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">getImageData</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">data</span>.<span class="cm-property">data</span>);
}

<span class="cm-keyword">var</span> <span class="cm-variable">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"canvas"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
<span class="cm-variable">pixelAt</span>(<span class="cm-variable">cx</span>, <span class="cm-number">10</span>, <span class="cm-number">10</span>);
<span class="cm-comment">// → [0, 0, 0, 0]</span>

<span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
<span class="cm-variable">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
<span class="cm-variable">pixelAt</span>(<span class="cm-variable">cx</span>, <span class="cm-number">10</span>, <span class="cm-number">10</span>);
<span class="cm-comment">// → [255, 0, 0, 255]</span></pre>
<p>The arguments to <code>getImageData</code> indicate the starting x- and
y-coordinates of the rectangle we want to retrieve, followed by its
width and height.</p>
<p>Ignore transparency during this exercise and look
only at the first three values for a given pixel. Also, do not worry
about updating the color field when the user picks a color. Just make
sure that the drawing context&#8217;s <code>fillStyle</code> and <code>strokeStyle</code> are set
to the color under the mouse cursor.</p>
<p>Remember that these properties accept any color that
CSS understands, which includes the <code>rgb(R, G, B)</code> style you saw in
<a href="15_game.xhtml#game_css">Chapter 15</a>.</p>
<p>The
<code>getImageData</code> method is subject to the same restrictions as
<code>toDataURL</code>—it will raise an error when the canvas contains pixels
that originate from another domain. Use a <code>try/catch</code> statement to
report such errors with an <code>alert</code> dialog.</p>
<h3>Flood fill</h3>
<p>This is a more advanced exercise than the
preceding two, and it will require you to design a nontrivial solution
to a tricky problem. Make sure you have plenty of time and
patience before starting to work on this exercise, and do not get
discouraged by initial failures.</p>
<p>A flood fill tool colors the pixel under the mouse
and the surrounding pixels of the same color. For
the purpose of this exercise, we will consider such a group to include
all pixels that can be reached from our starting pixel by moving in
single-pixel horizontal and vertical steps (not diagonal), without
ever touching a pixel that has a color different from the starting
pixel.</p>
<p>The following image illustrates the set of pixels colored when the flood
fill tool is used at the marked pixel:</p>
<div class="image">
  <img src="img/flood-grid.svg" alt="Flood fill example"/>
</div>
<p>The flood fill does not leak through diagonal gaps and does not touch
pixels that are not reachable, even if they have the same color as the
target pixel.</p>
<p>You will once again need
<code>getImageData</code> to find out the color for each pixel. It is
probably a good idea to fetch the whole image in one go and then pick
out pixel data from the resulting array. The pixels are organized in
this array in a similar way to the grid elements in
<a href="07_elife.xhtml#grid">Chapter 7</a>, one row at a time, except that
each pixel is represented by four values. The first value for the
pixel at (<em>x</em>,<em>y</em>) is at position (<em>x</em> + <em>y</em> × width) × 4.</p>
<p>Do include the fourth (alpha) value this
time since we want to be able to tell the difference between empty
and black pixels.</p>
<p>Finding all adjacent pixels with the same color
requires you to “walk” over the pixel surface, one pixel up, down,
left, or right, as long as new same-colored pixels can be found. But
you won&#8217;t find all pixels in a group on the first walk. Rather, you
have to do something similar to the backtracking done by the regular
expression matcher, described in
<a href="09_regexp.xhtml#backtracking">Chapter 9</a>. Whenever more than one
possible direction to proceed is seen, you must store all the
directions you do not take immediately and look at them later, when
you finish your current walk.</p>
<p>In a normal-sized picture, there are
a <em>lot</em> of pixels. Thus, you must take care to do the minimal amount
of work required or your program will take a very long time to run. For
example, every walk must ignore pixels seen by previous walks so that
it does not redo work that has already been done.</p>
<p>I recommend calling <code>fillRect</code> for individual
pixels when a pixel that should be colored is found, and keeping some
data structure that tells you about all the pixels that have already
been looked at.</p>
</div>
    </article>
  </body>
</html>
