<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Modules</title>
    <link rel="stylesheet" href="style.css"/>
  </head>
  <body>
    <article>

<h1 id="modules"><span class="chap_num">Chapter 10</span>Modules</h1>
<p>Every program has a shape. On
a small scale, this shape is determined by its division into
functions and the blocks inside those functions. Programmers have
a lot of freedom in the way they structure their programs. Shape follows
more from the taste of the programmer than from the program&#8217;s
intended functionality.</p>
<p>When looking at a larger program in its entirety,
individual functions start to blend into the background. Such a
program can be made more readable if we have a larger unit of
organization.</p>
<p><em>Modules</em> divide programs into clusters of code that, by <em>some</em>
criterion, belong together. This chapter explores some of the benefits
that such division provides and shows techniques for building
modules in JavaScript.</p>
<div id="ch10_sec01">
<h2>Why modules help</h2>
<p>There are a number of reasons why
authors divide their books into chapters and sections. These
divisions make it easier for a reader to see how the book is built up
and to find specific parts that they are interested in. They also help
the <em>author</em> by providing a clear focus for every section.</p>
<p>The benefits of organizing a program into several files or
modules are similar. Structure helps people who aren&#8217;t yet
familiar with the code find what they are looking for and makes it
easier for the programmer to keep things that are related
close together.</p>
<p>Some
programs are even organized along the model of a traditional text,
with a well-defined order in which the reader is encouraged to go
through the program and with lots of prose (comments) providing a coherent
description of the code. This makes reading the program a lot less
intimidating—reading unknown code is usually intimidating—but has the
downside of being more work to set up. It also makes the program more
difficult to change because prose tends to be more tightly
interconnected than code. This style is called <em>literate programming</em>. The “project” chapters of this book can be considered
literate programs.</p>
<p>As a
general rule, structuring things costs energy. In the early stages of
a project, when you are not quite sure yet what goes where or what
kind of modules the program needs at all, I endorse a minimalist,
structureless attitude. Just put everything wherever it is convenient
to put it until the code stabilizes. That way, you won&#8217;t be wasting
time moving pieces of the program back and forth, and you won&#8217;t
accidentally lock yourself into a structure that does not actually fit
your program.</p>
<h3>Namespacing</h3>
<p>Most modern programming languages have a
scope level between <em>global</em> (everyone can see it) and <em>local</em>
(only this function can see it). JavaScript does not. Thus, by
default, everything that needs to be visible outside of the scope of a
top-level function is visible <em>everywhere</em>.</p>
<p>Namespace pollution, the problem of a lot of
unrelated code having to share a single set of global variable names,
was mentioned in <a href="04_data.xhtml#namespace_pollution">Chapter 4</a>,
where the <code>Math</code> object was given as an example of an object that acts
like a module by grouping math-related functionality.</p>
<p>Though JavaScript provides no actual
module construct yet, objects can be used to create publicly
accessible subnamespaces, and functions can be used to create an
isolated, private namespace inside of a module. Later in this chapter,
I will discuss a way to build reasonably convenient, namespace-isolating
modules on top of the primitive concepts that JavaScript gives us.</p>
<h3>Reuse</h3>
<p>In a “flat” project, which isn&#8217;t
structured as a set of modules, it is not apparent which parts of
the code are needed to use a particular function. In my program for
spying on my enemies (see <a href="09_regexp.xhtml#ini">Chapter 9</a>), I wrote
a function for reading configuration files. If I want to use that
function in another project, I must go and copy out the parts of the
old program that look like they are relevant to the functionality that
I need and paste them into my new program. Then, if I find a mistake
in that code, I&#8217;ll fix it only in whichever program that I&#8217;m working
with at the time and forget to also fix it in the other program.</p>
<p>Once you have lots of such shared, duplicated pieces
of code, you will find yourself wasting a lot of time and energy on
moving them around and keeping them up-to-date.</p>
<p>Putting pieces of functionality that stand on their own
into separate files and modules makes them easier to track, update,
and share because all the various pieces of code that want to use the
module load it from the same actual file.</p>
<p>This
idea gets even more powerful when the relations between modules—which
other modules each module depends on—are explicitly stated. You can
then automate the process of installing and upgrading external modules
(<em>libraries</em>).</p>
<p>Taking this idea even
further, imagine an online service that tracks and distributes
hundreds of thousands of such libraries, allowing you to search for
the functionality you need and, once you find it, set up your project
to automatically download it.</p>
<p id="modules_npm">This service exists. It is called NPM
(<a href="http://npmjs.org"><em>npmjs.org</em></a>). NPM consists of an online database of
modules and a tool for downloading and upgrading the modules your
program depends on. It grew out of Node.js, the browserless
JavaScript environment we will discuss in
<a href="20_node.xhtml#node">Chapter 20</a>, but can also be useful when
programming for the browser.</p>
<h3>Decoupling</h3>
<p>Another important role of modules is isolating pieces
of code from each other, in the same way that the object interfaces
from <a href="06_object.xhtml#interface">Chapter 6</a> do. A well-designed
module will provide an interface for external code to use. As the
module gets updated with bug fixes and new functionality, the
existing interface stays the same (it is <em>stable</em>) so that other
modules can use the new, improved version without any changes to
themselves.</p>
<p>Note that a stable interface does not mean no new
functions, methods, or variables are added. It just means that
existing functionality isn&#8217;t removed and its meaning is not changed.</p>
<p>A good module
interface should allow the module to grow without breaking the old
interface. This means exposing as few of the module&#8217;s internal
concepts as possible while also making the “language” that the
interface exposes powerful and flexible enough to be applicable in a
wide range of situations.</p>
<p>For interfaces that expose a single, focused
concept, such as a configuration file reader, this design comes
naturally. For others, such as a text editor, which has many different
aspects that external code might need to access (content, styling,
user actions, and so on), it requires careful design.</p>
</div>
<div id="ch10_sec02">
<h2>Using functions as namespaces</h2>
<p>Functions are the only things in
JavaScript that create a new scope. So if we want our modules
to have their own scope, we will have to base them on functions.</p>
<p>Consider this
trivial module for associating names with day-of-the-week numbers, as
returned by a <code>Date</code> object&#8217;s <code>getDay</code> method:</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
             <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
<span class="cm-keyword">function</span> <span class="cm-variable">dayName</span>(<span class="cm-def">number</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>[<span class="cm-variable-2">number</span>];
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayName</span>(<span class="cm-number">1</span>));
<span class="cm-comment">// → Monday</span></pre>
<p>The <code>dayName</code> function is part
of the module&#8217;s interface, but the <code>names</code> variable is not. We
would prefer <em>not</em> to spill it into the global scope.</p>
<p>We can do this:</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">dayName</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>];
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayName</span>(<span class="cm-number">3</span>));
<span class="cm-comment">// → Wednesday</span></pre>
<p>Now <code>names</code> is a local variable in an
(unnamed) function. This function is created and immediately called,
and its return value (the actual <code>dayName</code> function) is stored in a
variable. We could have pages and pages of code in this function, with
100 local variables, and they would all be internal to our
module—visible to the module itself but not to outside code.</p>
<p>We can use a similar pattern to
isolate code from the outside world entirely. The following module logs a
value to the console but does not actually provide any values for
other modules to use:</p>
<pre>(<span class="cm-keyword">function</span>() {
  <span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; }
  <span class="cm-keyword">var</span> <span class="cm-def">hundred</span> <span class="cm-operator">=</span> <span class="cm-number">100</span>;

  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">square</span>(<span class="cm-variable-2">hundred</span>));
})();
<span class="cm-comment">// → 10000</span></pre>
<p>This code simply outputs the square of 100,
but in the real world it could be a module that adds a method
to some prototype or sets up a widget on a web page. It is
wrapped in a function to prevent the variables it uses internally from
polluting the global scope.</p>
<p>Why did we wrap the namespace
function in a pair of parentheses? This has to do with a quirk in
JavaScript&#8217;s syntax. If an <em>expression</em> starts with the
keyword <code>function</code>, it is a function expression. However, if a
<em>statement</em> starts with <code>function</code>, it is a function
<em>declaration</em>, which requires a name and, not being an expression,
cannot be called by writing parentheses after it. You can think of the
extra wrapping parentheses as a trick to force the function to be
interpreted as an expression.</p>
</div>
<div id="ch10_sec03">
<h2>Objects as interfaces</h2>
<p>Now imagine that we want to add another function to our
day-of-the-week module, one that goes from a day name to a
number. We can&#8217;t simply return the function anymore but must wrap the
two functions in an object.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">weekDay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>: <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>: <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">"Sunday"</span>)));
<span class="cm-comment">// → Sunday</span></pre>
<p>For bigger modules,
gathering all the <em>exported</em> values into an object at the end of the
function becomes awkward since many of the exported functions are
likely to be big and you&#8217;d prefer to write them somewhere else, near
related internal code. A convenient alternative is to declare an
object (conventionally named <code>exports</code>) and add properties to that
whenever we are defining something that needs to be exported. In the
following example, the module function takes its interface object as
an argument, allowing code outside of the function to create it and store
it in a variable. (Outside of a function, <code>this</code> refers to the global
scope object.)</p>
<pre>(<span class="cm-keyword">function</span>(<span class="cm-def">exports</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];

  <span class="cm-variable-2">exports</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>];
  };
  <span class="cm-variable-2">exports</span>.<span class="cm-property">number</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>);
  };
})(<span class="cm-keyword">this</span>.<span class="cm-property">weekDay</span> <span class="cm-operator">=</span> {});

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">"Saturday"</span>)));
<span class="cm-comment">// → Saturday</span></pre>
</div>
<div id="ch10_sec04">
<h2>Detaching from the global scope</h2>
<p>The previous pattern is commonly used by JavaScript
modules intended for the browser. The module will claim a single
global variable and wrap its code in a function in order to have its
own private namespace. But this pattern still causes problems if
multiple modules happen to claim the same name or if you want to load
two versions of a module alongside each other.</p>
<p>With a little plumbing, we
can create a system that allows one module to directly ask for the
interface object of another module, without going through the
global scope. Our goal is a <code>require</code> function that, when given a
module name, will load that module&#8217;s file (from disk or the Web,
depending on the platform we are running on) and return the
appropriate interface value.</p>
<p>This approach solves the problems mentioned previously and has the added
benefit of making your program&#8217;s dependencies explicit, making it
harder to accidentally make use of some module without stating that
you need it.</p>
<p>For <code>require</code> we need two
things. First, we want a function <code>readFile</code>, which returns the
content of a given file as a string. (A single such function is not
present in standard JavaScript, but different JavaScript
environments, such as the browser and Node.js, provide their own ways
of accessing files. For now, let&#8217;s just pretend we have this
function.) Second, we need to be able to actually execute this
string as JavaScript code.</p>
</div>
<div id="ch10_sec05">
<h2 id="eval">Evaluating data as code</h2>
<p>There are several ways to take
data (a string of code) and run it as part of the current program.</p>
<p>The most obvious way is the special operator
<code>eval</code>, which will execute a string of code in the <em>current</em> scope.
This is usually a bad idea because it breaks some of the sane
properties that scopes normally have, such as being isolated from the
outside world.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">evalAndReturnX</span>(<span class="cm-def">code</span>) {
  <span class="cm-variable">eval</span>(<span class="cm-variable-2">code</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">x</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evalAndReturnX</span>(<span class="cm-string">"var x = 2"</span>));
<span class="cm-comment">// → 2</span></pre>
<p>A better way of interpreting data as code is
to use the <code>Function</code> constructor. This takes two arguments: a string
containing a comma-separated list of argument names and a string
containing the function&#8217;s body.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">plusOne</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"n"</span>, <span class="cm-string">"return n + 1;"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">plusOne</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 5</span></pre>
<p>This is precisely what we need for our modules. We can wrap a module&#8217;s
code in a function, with that function&#8217;s scope becoming our module
scope.</p>
</div>
<div id="ch10_sec06">
<h2 id="commonjs">Require</h2>
<p>The following is a minimal
implementation of <code>require</code>:</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"exports"</span>, <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> {};
  <span class="cm-variable-2">code</span>(<span class="cm-variable-2">exports</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">exports</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">require</span>(<span class="cm-string">"weekDay"</span>).<span class="cm-property">name</span>(<span class="cm-number">1</span>));
<span class="cm-comment">// → Monday</span></pre>
<p>Since the <code>new Function</code> constructor wraps the module
code in a function, we don&#8217;t have to write a wrapping namespace
function in the module file itself. And since we make <code>exports</code> an
argument to the module function, the module does not have to declare
it. This removes a lot of clutter from our example module.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
             <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];

<span class="cm-variable">exports</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>[<span class="cm-variable-2">number</span>];
};
<span class="cm-variable">exports</span>.<span class="cm-property">number</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>);
};</pre>
<p>When using this pattern, a module typically
starts with a few variable declarations that load the modules it
depends on.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">weekDay</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">"weekDay"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">today</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">"today"</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">today</span>.<span class="cm-property">dayNumber</span>()));</pre>
<p>The simplistic implementation of <code>require</code> given previously
has several problems. For one, it will load and run a module every
time it is <code>require</code>d, so if several modules have the same
dependency or a <code>require</code> call is put inside a function that will
be called multiple times, time and energy will be wasted.</p>
<p>This can be solved by storing the modules that have already
been loaded in an object and simply returning the existing value when
one is loaded multiple times.</p>
<p>The second problem is that it is
not possible for a module to directly export a value other than the
<code>exports</code> object, such as a function. For example, a module might want
to export only the constructor of the object type it defines. Right
now, it cannot do that because <code>require</code> always uses the <code>exports</code>
object it creates as the exported value.</p>
<p>The traditional solution for this is to provide
modules with another variable, <code>module</code>, which is an object that has a
property <code>exports</code>. This property initially points at the empty object
created by <code>require</code> but can be overwritten with another value in
order to export something else.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>];

  <span class="cm-keyword">var</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"exports, module"</span>, <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> {}, <span class="cm-keyword">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: <span class="cm-variable-2">exports</span>};
  <span class="cm-variable-2">code</span>(<span class="cm-variable-2">exports</span>, <span class="cm-keyword">module</span>);

  <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-keyword">module</span>.<span class="cm-variable-2">exports</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">module</span>.<span class="cm-variable-2">exports</span>;
}
<span class="cm-variable">require</span>.<span class="cm-property">cache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);</pre>
<p>We now have a module system that uses a single
global variable (<code>require</code>) to allow modules to find and use each
other without going through the global scope.</p>
<p>This style of module system is called <em>CommonJS modules</em>, after
the pseudo-standard that first specified it. It is built into the
Node.js system. Real implementations do a lot more than the
example I showed. Most importantly, they have a much more intelligent
way of going from a module name to an actual piece of code, allowing
both pathnames relative to the current file and module names that
point directly to locally installed modules.</p>
</div>
<div id="ch10_sec07">
<h2 id="amd">Slow-loading modules</h2>
<p>Though it is possible to use the CommonJS module style when
writing JavaScript for the browser, it is somewhat involved. The
reason for this is that reading a file (module) from the Web is a lot
slower than reading it from the hard disk. While a script is running
in the browser, nothing else can happen to the website on which it
runs, for reasons that will become clear in
<a href="14_event.xhtml#timeline">Chapter 14</a>. This means that if every
<code>require</code> call went and fetched something from some faraway web
server, the page would freeze for a painfully long time while loading
its scripts.</p>
<p>One way to
work around this problem is to run a program like
<a href="http://browserify.org"><em>Browserify</em></a> on your code before you serve it
on a web page. This will look for calls to <code>require</code>, resolve all
dependencies, and gather the needed code into a single big file.
The website itself can simply load this file to get all the modules
it needs.</p>
<p>Another solution is to wrap the
code that makes up your module in a function so that the module loader can first load its dependencies in the background and then
call the function, initializing the module, when the dependencies
have been loaded. That is what the Asynchronous Module Definition
(AMD) module system does.</p>
<p>Our trivial program with dependencies would look
like this in AMD:</p>
<pre><span class="cm-variable">define</span>([<span class="cm-string">"weekDay"</span>, <span class="cm-string">"today"</span>], <span class="cm-keyword">function</span>(<span class="cm-def">weekDay</span>, <span class="cm-def">today</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable-2">today</span>.<span class="cm-property">dayNumber</span>()));
});</pre>
<p>The <code>define</code>
function is central to this approach. It takes first an array of
module names and then a function that takes one argument for each
dependency. It will load the dependencies (if they haven&#8217;t already
been loaded) in the background, allowing the page to continue working
while the files are being fetched. Once all dependencies are loaded,
<code>define</code> will call the function it was given, with the interfaces
of those dependencies as arguments.</p>
<p>The modules that are loaded
this way must themselves contain a call to <code>define</code>. The value used as
their interface is whatever was returned by the function passed to
<code>define</code>. Here is the <code>weekDay</code> module again:</p>
<pre><span class="cm-variable">define</span>([], <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>: <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>: <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
});</pre>
<p>To be
able to show a minimal implementation of <code>define</code>, we will pretend we
have a <code>backgroundReadFile</code> function that takes a filename and a
function and calls the function with the content of the file as
soon as it has finished loading it. (<a href="17_http.xhtml#getURL">Chapter
17</a> will explain how to write that function.)</p>
<p>For the purpose of keeping track of modules while they are being
loaded, the implementation of <code>define</code> will use objects that describe
the state of modules, telling us whether they are available yet and
providing their interface when they are.</p>
<p>The <code>getModule</code> function, when given a name, will return such an
object and ensure that the module is scheduled to be loaded. It uses
a cache object to avoid loading the same module twice.</p>
<pre><span class="cm-keyword">var</span> <span class="cm-variable">defineCache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">currentMod</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;

<span class="cm-keyword">function</span> <span class="cm-variable">getModule</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">defineCache</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">defineCache</span>[<span class="cm-variable-2">name</span>];

  <span class="cm-keyword">var</span> <span class="cm-keyword">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: <span class="cm-atom">null</span>,
                <span class="cm-property">loaded</span>: <span class="cm-atom">false</span>,
                <span class="cm-property">onLoad</span>: []};
  <span class="cm-variable">defineCache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-keyword">module</span>;
  <span class="cm-variable">backgroundReadFile</span>(<span class="cm-variable-2">name</span>, <span class="cm-keyword">function</span>(<span class="cm-def">code</span>) {
    <span class="cm-variable">currentMod</span> <span class="cm-operator">=</span> <span class="cm-keyword">module</span>;
    <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">""</span>, <span class="cm-variable-2">code</span>)();
  });
  <span class="cm-keyword">return</span> <span class="cm-keyword">module</span>;
}</pre>
<p>We assume the loaded file also contains a
(single) call to <code>define</code>. The <code>currentMod</code> variable is used to tell
this call about the module object that is currently being loaded so
that it can update this object when it finishes loading. We will come
back to this mechanism in a moment.</p>
<p>The <code>define</code> function itself uses
<code>getModule</code> to fetch or create the module objects for the current
module&#8217;s dependencies. Its task is to schedule the <code>moduleFunction</code>
(the function that contains the module&#8217;s actual code) to be run
whenever those dependencies are loaded. For this purpose, it defines a
function <code>whenDepsLoaded</code> that is added to the <code>onLoad</code> array of all
dependencies that are not yet loaded. This function immediately
returns if there are still unloaded dependencies, so it will do
actual work only once, when the last dependency has finished loading. It is
also called immediately, from <code>define</code> itself, in case there are no
dependencies that need to be loaded.</p>
<pre><span class="cm-keyword">function</span> <span class="cm-variable">define</span>(<span class="cm-def">depNames</span>, <span class="cm-def">moduleFunction</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">myMod</span> <span class="cm-operator">=</span> <span class="cm-variable">currentMod</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">deps</span> <span class="cm-operator">=</span> <span class="cm-variable-2">depNames</span>.<span class="cm-property">map</span>(<span class="cm-variable">getModule</span>);

  <span class="cm-variable-2">deps</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">mod</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">mod</span>.<span class="cm-property">loaded</span>)
      <span class="cm-variable-2">mod</span>.<span class="cm-property">onLoad</span>.<span class="cm-property">push</span>(<span class="cm-variable">whenDepsLoaded</span>);
  });

  <span class="cm-keyword">function</span> <span class="cm-def">whenDepsLoaded</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">deps</span>.<span class="cm-property">every</span>(<span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span>.<span class="cm-property">loaded</span>; }))
      <span class="cm-keyword">return</span>;

    <span class="cm-keyword">var</span> <span class="cm-def">args</span> <span class="cm-operator">=</span> <span class="cm-variable-2">deps</span>.<span class="cm-property">map</span>(<span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span>.<span class="cm-property">exports</span>; });
    <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> <span class="cm-variable-2">moduleFunction</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">args</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">myMod</span>) {
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">exports</span> <span class="cm-operator">=</span> <span class="cm-variable-2">exports</span>;
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">loaded</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">onLoad</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">f</span>) { <span class="cm-variable-2">f</span>(); });
    }
  }
  <span class="cm-variable-2">whenDepsLoaded</span>();
}</pre>
<p>When all dependencies are available,
<code>whenDepsLoaded</code> calls the function that holds the module, giving it
the dependencies’ interfaces as arguments.</p>
<p>The first thing <code>define</code> does is store the value that <code>currentMod</code> had
when it was called in a variable <code>myMod</code>. Remember that <code>getModule</code>,
just before evaluating the code for a module, stored the corresponding
module object in <code>currentMod</code>. This allows <code>whenDepsLoaded</code> to store
the return value of the module function in that module&#8217;s <code>exports</code>
property, set the module&#8217;s <code>loaded</code> property to true, and call all the
functions that are waiting for the module to load.</p>
<p>This code is a lot harder to follow than
the <code>require</code> function. Its execution does not follow a simple,
predictable path. Instead, multiple operations are set up to happen at
some unspecified time in the future, which obscures the way the
code executes.</p>
<p>A real AMD implementation is, again, quite a lot more clever about
resolving module names to actual URLs and generally more robust than
the one shown previously. The <em>RequireJS</em> (<a href="http://requirejs.org"><em>requirejs.org</em></a>) project provides
a popular implementation of this style of module loader.</p>
</div>
<div id="ch10_sec08">
<h2>Interface design</h2>
<p>Designing interfaces for modules and object
types is one of the subtler aspects of programming. Any nontrivial
piece of functionality can be modeled in various ways. Finding a way that
works well requires insight and foresight.</p>
<p>The best way to learn the value of good interface design is to use
lots of interfaces—some good, some bad. Experience will teach
you what works and what doesn&#8217;t. Never assume that a painful interface
is “just the way it is”. Fix it, or wrap it in a new interface that
works better for you.</p>
<h3>Predictability</h3>
<p>If programmers
can predict the way your interface works, they (or you) won&#8217;t get
sidetracked as often by the need to look up how to use it. Thus, try
to follow conventions. When there is another module or part of the
standard JavaScript environment that does something similar to what
you are implementing, it might be a good idea to make your interface
resemble the existing interface. That way, it&#8217;ll feel familiar to
people who know the existing interface.</p>
<p>Another area where predictability is important is the
actual <em>behavior</em> of your code. It can be tempting to make an
unnecessarily clever interface with the justification that it&#8217;s more
convenient to use. For example, you could accept all kinds of
different types and combinations of arguments and do the “right
thing” for all of them. Or you could provide dozens of specialized
convenience functions that provide slightly different flavors of your
module&#8217;s functionality. These might make code that builds on your
interface slightly shorter, but they will also make it much harder for
people to build a clear mental model of the module&#8217;s behavior.</p>
<h3>Composability</h3>
<p>In your interfaces, try to use the simplest data structures possible and make functions do a single, clear thing.
Whenever practical, make them pure functions (see
<a href="03_functions.xhtml#pure">Chapter 3</a>).</p>
<p>For example, it is not uncommon for modules to
provide their own array-like collection objects, with their own
interface for counting and extracting elements. Such objects won&#8217;t
have <code>map</code> or <code>forEach</code> methods, and any existing function that
expects a real array won&#8217;t be able to work with them. This is an
example of poor <em>composability</em>—the module cannot be easily composed
with other code.</p>
<p>One example would be a
module for spell-checking text, which we might need when we want to
write a text editor. The spell-checker could be made to operate
directly on whichever complicated data structures the editor uses
and directly call internal functions in the editor to have the user
choose between spelling suggestions. If we go that way, the module
cannot be used with any other programs. On the other hand, if we
define the spell-checking interface so that you can pass it a simple
string and it will return the position in the string where it found a
possible misspelling, along with an array of suggested corrections,
then we have an interface that could also be composed with other
systems because strings and arrays are always available in
JavaScript.</p>
<h3>Layered interfaces</h3>
<p>When designing an interface for a complex piece of
functionality—sending email, for example—you often run into a dilemma.
On the one hand, you do not want to overload the user of your
interface with details. They shouldn&#8217;t have to study your interface
for 20 minutes before they can send an email. On the other hand, you
do not want to hide all the details either—when people need to do
complicated things with your module, they should be able to.</p>
<p>Often the solution is to provide two interfaces: a detailed
<em>low-level</em> one for complex situations and a simple <em>high-level</em> one
for routine use. The second can usually be built easily using the
tools provided by the first. In the email module, the high-level
interface could just be a function that takes a message, a sender
address, and a receiver address and then sends the email. The low-level
interface would allow full control over email headers, attachments,
HTML mail, and so on.</p>
</div>
<div id="ch10_sec09">
<h2>Summary</h2>
<p>Modules provide structure to bigger programs by separating the code
into different files and namespaces. Giving these modules well-defined
interfaces makes them easier to use and reuse
and makes it possible to continue using them as the module
itself evolves.</p>
<p>Though the JavaScript language is characteristically unhelpful
when it comes to modules, the flexible functions and objects it
provides make it possible to define rather nice module systems.
Function scopes can be used as internal namespaces for the module, and
objects can be used to store sets of exported values.</p>
<p>There are two popular, well-defined approaches to such modules. One is
called <em>CommonJS Modules</em> and revolves around a <code>require</code> function
that fetches a module by name and returns its interface. The other is
called <em>AMD</em> and uses a <code>define</code> function that takes an array of
module names and a function and, after loading the modules, runs the
function with their interfaces as arguments.</p>
</div>
<div id="ch10_sec10">
<h2>Exercises</h2>
<h3>Month names</h3>
<p>Write a
simple module similar to the <code>weekDay</code> module that can convert month
numbers (zero-based, as in the <code>Date</code> type) to names and can convert names back
to numbers. Give it its own namespace since it will need an internal
array of month names, and use plain JavaScript, without any module
loader system.</p>
<h3>A return to electronic life</h3>
<p>Hoping that
<a href="07_elife.xhtml#elife">Chapter 7</a> is still somewhat fresh in your
mind, think back to the system designed in that chapter and come up
with a way to separate the code into modules. To refresh your memory,
these are the functions and types defined in that chapter, in order of
appearance:</p>
<pre>Vector
Grid
directions
directionNames
randomElement
BouncingCritter
elementFromChar
World
charFromElement
Wall
View
WallFollower
dirPlus
LifelikeWorld
Plant
PlantEater
SmartPlantEater
Tiger</pre>
<p>Don&#8217;t exaggerate and create too many modules. A book
that starts a new chapter for every page would probably get on your
nerves, if only because of all the space wasted on titles. Similarly,
having to open 10 files to read a tiny project isn&#8217;t helpful. Aim for
three to five modules.</p>
<p>You can choose to have some functions become
internal to their module and thus inaccessible to other modules.</p>
<p>There is no single correct solution here. Module organization is
largely a matter of taste.</p>
<h3>Circular dependencies</h3>
<p>A
tricky subject in dependency management is circular dependencies,
where module A depends on B, and B also depends on A. Many module
systems simply forbid this. CommonJS modules allow a limited form:
it works as long as the modules do not replace their default <code>exports</code>
object with another value and start accessing each other&#8217;s
interface only after they finish loading.</p>
<p>Can you think of a way in which support for this feature could be
implemented? Look back to the definition of <code>require</code> and consider
what the function would have to do to allow this.</p>
</div>
    </article>
  </body>
</html>
